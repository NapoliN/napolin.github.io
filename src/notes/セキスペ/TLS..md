---
title: セキスペ入門 TLS
tags: 
 - セキスペ
 - 執筆中
date: 2025/10/29
---

# セキスペ入門 TLS
**この記事は執筆中です。いつかちゃんと書きます。**
::: info
セキスペ入門とか書いてるけどたぶん余計な情報いっぱい入ってます。(応用)とか(発展)とか書いてるところは覚える必要ないと思う。
:::
Transport Layer Security.
インターネット上の通信を暗号化し、盗聴や改ざん、なりすましを防止するためのプロトコル。古くはSSL(Secure Sockets Layer)と呼ばれていたため、SSL/TLSと呼称する場合もある。

TLSを利用することで、以下の3つのセキュリティ目標を達成できる。
- 機密性: 通信内容を暗号化し、第三者に読まれないようにする
- 完全性: 通信内容が改ざんされていないことを確認する
- 認証: 通信相手が正当な相手であることを確認する

## バージョン
SSL/TLSは歴史が古く、互換性のない複数のバージョンが存在する。
欠陥が発見された古いバージョンは廃止されており、現在ではTLS1.2以降が主に使用されている。
現行のTLS1.2およびTLS1.3は差分が大きいので、注意が必要。

**本節では、以降TLS1.2を前提として説明する。**

| バージョン | 発行年 | RFC | 備考 |
|---|---|---|---|
| SSL 3.0 | 1996 | - | POODLE攻撃に脆弱であるため、使用禁止 |
| TLS 1.0 | 1999 | RFC 2246 | BEAST攻撃に脆弱であるため、多くの場合廃止されている |
| TLS 1.1 | 2006 | RFC 4346 | 短期間のうちにTLS1.2が登場したため、あまり普及しなかった |
| TLS 1.2 | 2008 | RFC 5246 | 現在も広く使われている |
| TLS 1.3 | 2018 | RFC 8446 | 最新版。多くの古い暗号スイートが廃止され、セキュリティを強化 |

## ハンドシェイク
暗号化通信を開始する前に、クライアントとサーバで通信相手の認証や暗号化方式の決定、鍵交換などを行うプロセス。


### TLS1.2 ハンドシェイクの流れ
一般的なWebサイトにHTTPS通信でアクセスするときをイメージして、ハンドシェイクのシーケンスを示す。
図のように、通信を2回往復するので、2RTT(2 Round Trip Time)かかる。
TLSハンドシェイク以前にTCPの3way-handshakeを行う必要があるため、実際のデータ送信までは3RTTかかる。

::: mermaid
sequenceDiagram
    participant C as クライアント
    participant S as サーバ
    autonumber
    rect lightblue
    Note right of C : 1st RTT <br/> アルゴリズムの決定および通信相手の検証フェーズ
    C->>S: ClientHello:対応暗号スイートの提示
    S-->>C: ServerHello:暗号スイートの選択
    S-->>C: Server Certificate:サーバ証明書送信
    S-->>C: ServerHelloDone:サーバハンドシェイク完了通知
    end
    C->>C: サーバ証明書の検証
    rect lightblue
    Note right of C : 2nd RTT <br/> 鍵交換フェーズ
    C->>S: ClientKeyExchange:鍵交換に必要な情報の送信
    C->>S: ChangeCipherSpec:暗号化通信開始通知
    C->>S: Finished: ハンドシェイク完了通知（暗号化）
    S-->>C: ChangeCipherSpec:暗号化通信開始通知
    S-->>C: Finished: ハンドシェイク完了通知（暗号化）
    end
    Note over C,S: ✅ 以降、上位プロトコル(HTTPなど)の通信を暗号化して行う
:::


1. **ClientHello**: クライアントは対応可能な暗号スイートを提示する。また、このとき乱数(クライアントランダム)を送信する。この乱数値は後の鍵生成に使用される。
2. **ServerHello**: サーバはクライアントが提示した暗号スイートの中から1つを選択し、サーバランダムとともに返信する。
3. **Server Certificate**: サーバは自身の公開鍵証明書を送信する。ルート証明書までの証明書チェーンを含む。
4. **ServerHelloDone**: サーバはハンドシェイクメッセージの送信を終了したことを通知する。
5. **サーバ証明書の検証**: クライアントは受信したサーバ証明書を検証する。自身がもつ信頼済みCAのルート証明書を用いて、証明書チェーンを検証し、サーバの正当性を確認する。
6. **ClientKeyExchange**: セッション鍵の共有に必要な情報を送信する。
7. **ChangeCipherSpec**: クライアントは以降の通信を暗号化することを通知する。
8. **Finished**: クライアントはハンドシェイクが正常に完了したことを暗号化メッセージで通知する。
9. **ChangeCipherSpec**: サーバは以降の通信を暗号化することを通知する。
10. **Finished**: サーバはハンドシェイクが正常に完了したことを暗号化メッセージで通知する。

::: info
**サーバ公開鍵の共有**

手順3はサーバがクライアントに対してサーバ証明書を提示するフェーズ。基本的にはサーバ証明書に公開鍵が含まれるため、クライアントはサーバの公開鍵を取得できる。
もしサーバ証明書に公開鍵が含まれない場合、あるいはそもそもサーバが証明書を提示しない場合、別途サーバ公開鍵を送信するメッセージが必要になる。
前者の場合、手順3のあとに「Server Key Exchange」メッセージが追加される。後者の場合、手順3が「Server Key Exchange」メッセージに差し替えられる。
:::

::: info
**クライアント認証**

企業内ネットワークへのアクセスなど、「特定のクライアントのみ接続を許可したい」場合、クライアントに対しても認証が行われる場合がある。
その場合、手順3のあとに「**Certificate Request**」メッセージが追加され、クライアントに証明書の提示を要求する。
このメッセージを受け取ったクライアントは、指定される条件に合致する証明書を探し、手順6の前に「Client Certificate」メッセージで提示する。
続いて、手順6のあとに「**Certificate Verify**」メッセージが追加され、クライアントは自身の秘密鍵で署名した値を送信する。
:::

::: warning
**手順5: サーバ証明書の検証が失敗したときの挙動について**

サーバ側からの証明書が、自己署名証明書であるなど、署名チェーンがブラウザに登録されている信頼済みCAに繋がっていない場合、署名検証に失敗する。
ブラウザの機能によって「この接続ではプライバシーが保護されません」とか警告が出るのはこれが原因。
:::

## 鍵交換
TLSにおいて、メッセージの暗号化には共通鍵暗号が使用される。
このとき、利用する暗号鍵は通信を行う相手と事前に共有しておく必要がある。
そのため、悪意のある第三者が通信を盗聴できる状態でも、安全に(鍵が第三者に知られないように)鍵を共有する方法が問題となる。
これを「**鍵配送問題**」と呼ぶ。

TLSでは以下のような手続きにより、安全に鍵の共有を行う。

::: dot
digraph G {
    rankdir=LR;
    node [shape=box,margin="0.3,0.2"];

    SharingRandom [label="1.クライアントランダム\nサーバランダムの共有"];
    SharingPreMasterSecret [label="2.プリマスタシークレット\nの共有"];
    GenerateMasterSecret [label="3.PRFでマスタシークレット\nを生成"];
    GenerateSessionKeys [label="4.マスタシークレットから\nセッション鍵を生成"];

    SharingRandom -> GenerateMasterSecret;
    SharingPreMasterSecret -> GenerateMasterSecret;
    GenerateMasterSecret -> GenerateSessionKeys;
}
:::

::: info
**PRF(Pseudo Random Function)**
疑似乱数生成関数。TLS1.2ではHMAC-SHA256が使われる。
ClientHello/ServerHelloで交換した乱数(クライアントランダム/サーバランダム)、およびプリマスタシークレットを入力として、マスタシークレットが生成される。
:::

### 1. クライアントランダム・サーバランダムの共有
1stRTTに含まれる ClientHello メッセージおよび ServerHello メッセージで、クライアントとサーバはそれぞれ乱数(クライアントランダム/サーバランダム)を交換する。
これらの値はセッションごとに生成され平文で交換されるランダムな値で、鍵生成の材料として利用される。

### 2. プリマスタシークレットの共有
前述のフローにおいて、セッション鍵のシードとなるプリマスタシークレットは鍵交換アルゴリズムによって異なる方法で交換される。
代表的な方法として、RSA鍵交換とDHE/ECDHE鍵交換の仕組みについて説明する。**鍵交換って言ってるけど、これをそのまま暗号鍵として使うわけじゃないという点に留意。**

#### RSA鍵交換
ClientKeyExchange メッセージの内容は、選択された鍵交換アルゴリズムによって異なる。

クライアントはプリマスタシークレットを生成し、サーバの公開鍵で暗号化して送信する。
サーバ側は秘密鍵で復号し、プリマスタシークレットを取得する。

::: mermaid
sequenceDiagram
    participant C as クライアント
    participant S as サーバ
    C->>C: プリマスタシークレットを生成
    C->>S: ClientKeyExchange <br/> プリマスタシークレットを<br/>サーバ公開鍵で暗号化して送信
    S->>S: サーバ秘密鍵で復号 <br/> プリマスタシークレットを取得
:::

#### DHE/ECDHE鍵交換
Diffie–Hellman Ephemeral / Elliptic Curve Diffie–Hellman Ephemeral.
Ephemeralとは、「一時的な」という意味で、その場限りで生成される鍵を用いることを表す。秘密鍵/公開鍵のペアはセッション限りの値なので、PFS(完全前方秘匿性)が保証される。
それぞれのアルゴリズムで具体的にどのような計算を行っているかは、本節の範囲を超える気がするので、どこか別のとこに書こうと思う。

ハンドシェイクの中から、鍵交換に必要なメッセージ部分のみを抜粋する。

::: mermaid
sequenceDiagram
    participant C as クライアント
    participant S as サーバ

    S-->>C: ServerKeyExchange <br/> サーバDHE公開鍵送信
    C-->>S: ClientKeyExchange <br/> クライアントDHE公開鍵送信

    Note over C,S: 双方で自身の秘密鍵・相手の公開鍵を用いて<br/>共有秘密値を計算<br/>プリマスタシークレットとして利用
:::

重要なのは、
**クライアントの秘密鍵+サーバの公開鍵**、および**サーバの秘密鍵+クライアントの公開鍵**を用いた計算結果が一致する、という点である。
第三者が盗聴可能なのは、サーバとクライアントの公開鍵のみであり、秘密鍵は送信されない。そのため、第三者に知られることなく共有秘密を生成できる。

### 3. マスタシークレットの生成
プリマスタシークレットはサーバとクライアントのみによって共有される秘密の値であるが、これをそのままセッション鍵としては使わない。
理由としては、
- 鍵交換方式によってはプリマスタシークレットのビット長が異なり、統一的に扱えないため
- リプレイ攻撃を防止するため

が挙げられる。
そのため、TLSでは、疑似乱数生成関数(PRF: Pseudo Random Function)を用いて、プリマスタシークレットからマスタシークレットを生成する。
PRFの入力には、以下の値を利用する。
- プリマスタシークレット (前述の手続きにより共有される)
- クライアントランダム (ClientHelloでサーバに送信)
- サーバランダム (ServerHelloでクライアントに送信)
- 固定文字列 "master secret"

利用されるPRFは暗号スイート指定時に決定され、SHA-256などを用いることができる。
::: info
暗号スイートのフォーマットは以下のような形式で表される。
```
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```
この場合、鍵交換アルゴリズムにECDHE、署名アルゴリズムにRSA、暗号化方式に128bit AESのGCMモード、MAC/PRFとしてSHA-256が利用される。
:::

$$
\mathit{master\\_secret} = \mathrm{PRF}(\mathit{pre\\_master\\_secret}, \ \text{"master secret"}, \ \mathit{client\\_random} \ || \ \mathit{server\\_random}) 
$$
により計算される。

サーバとクライアントで同じ処理を行うことで、48byteのマスタシークレットが生成、共有される。

::: success
**(発展)なぜプリマスタシークレットを直接用いるとリプレイ攻撃を起こせるのか？**
cf. [StackExchange](https://security.stackexchange.com/questions/218491/why-using-the-premaster-secret-directly-would-be-vulnerable-to-replay-attack?utm_source=chatgpt.com)

(RSA鍵交換で共有した)プリマスタシークレットをそのまま暗号化鍵として用いた場合、通信内容を盗聴できる中間者は以下の手順でリプレイ攻撃を成立させられる。
1. 一連のハンドシェイクおよびデータ通信を盗聴する
2. 攻撃者は新たにTLSセッションを開始する。このとき、ClientKeyExchangeとして、盗聴したClientKeyExchangeメッセージをそのまま送信する
3. TLSハンドシェイク成立後、盗聴したデータ通信をそのまま再送信する
4. サーバは同じプリマスタシークレットから同じセッション鍵を生成するため、攻撃者が再送信したデータ通信を正しく復号し、処理してしまう

これにより、攻撃者は直接プリマスタシークレットを解読できるわけではないが、同じ鍵を使った通信を再利用できてしまう。

共通鍵にサーバランダムの要素を与えることで、同じプリマスタシークレットを利用したとしてもセッション鍵が毎回変化するようになり、リプレイ攻撃を防止できる。
:::
下図：仮にプリマスタシークレットをそのまま暗号化鍵として使用した場合に成立するリプレイ攻撃の流れ

::: mermaid
sequenceDiagram
    participant C as クライアント
    participant A as 攻撃者
    participant S as サーバ
    autonumber
    C->>S: ClientKeyExchange <br/> プリマスタシークレットを<br/>サーバ公開鍵で暗号化して送信
    C->>S: プリマスタシークレットで暗号化したリクエスト
    S-->>C: プリマスタシークレットで暗号化したレスポンス
    Note over A: 上記の通信をすべて盗聴
    Note over A,S: 新たにTLSセッションを開始
    A->>S: ClientKeyExchange <br/> 盗聴した①のメッセージをそのまま再送 <br/> (暗号化が同じ鍵で行われる)
    A->>S: 盗聴した②のリクエストをそのまま再送
    S-->>A: レスポンスが返る
    Note right of A: 攻撃者は復号できないものの、<br/>同じリクエストを再送できてしまう
:::

### 4. セッション鍵の生成
マスタシークレットから、実際にメッセージの暗号化やMACに使用するセッション鍵を生成する。
マスタシークレットは48byte固定で長さが足りないので、さらにPRFを用いて必要な長さの鍵を生成する。
このとき生成される値を**key_block**と呼ぶ。

key_blockは以下のように計算される。

$$
\mathit{key\\_block} = \mathrm{PRF}(\mathit{master\\_secret}, \ \text{\"key expansion\"}, \ \mathit{server\\_random} \ || \ \mathit{client\\_random}) 
$$

により生成される。
生成した**key_block**から、以下の値を順番に切り出して利用する。
- **クライアントMAC鍵** : クライアントがメッセージ認証コード(MAC)を生成するための鍵
- **サーバMAC鍵** : サーバがメッセージ認証コード(MAC)を生成するための鍵
- **クライアント暗号化鍵** : クライアントがメッセージを暗号化するための鍵
- **サーバ暗号化鍵** : サーバがメッセージを暗号化するための鍵
- **クライアントIV** : クライアント暗号化に使用する初期化ベクトル(IV)
- **サーバIV** : サーバ暗号化に使用する初期化ベクトル(IV)

具体的なビット長はネゴシエーションで指定した暗号スイートによって異なる。

::: info
**PRFの実体って何？**

前節で説明したように、PRFはsha-256などのハッシュ関数を用いて実装される。
sha-256は任意の長さの入力を256bitの固定長で出力する関数であるため、マスタシークレットやkey_blcokのような長い値を生成することができない。
そのため、PRFはハッシュ関数を複数回適用し、出力を連結することで、必要な長さの疑似乱数列を生成する。
$$
\mathit{PRF}\ (\mathit{secret}, \mathit{label}, \mathit{seed}) \overset{\mathrm{def}}{=} P\_{hash}(\mathit{secret}, \mathit{label} ~||~ \mathit{seed}) 
$$

$$
P\_{hash}(\mathit{secret}, \mathit{seed})  \overset{\mathrm{def}}{=} ||_{k=1}^n~ \mathit{HMAC}\_{hash}(\mathit{secret}, A(k))
$$
ここで、$A(k)$は以下で定義される漸化式である。
$$
\begin{align}
A(0) &= \mathit{seed} \newline
A(k) &= \mathit{HMAC}\_{hash}(\mathit{secret}, A(k-1))
\end{align}
$$
つまり、前の出力を次のシードとして与えることで、連続した疑似乱数列を生成する。
例えばHMACがsha-256を用いるとき、1回の出力は32byteなので、マスタシークレット(48byte)を生成するには2回適用する必要がある。
:::

## TLSに対する攻撃手法
TLSは強力なセキュリティを提供するプロトコルだが、過去には仕様上の脆弱性、実装のバグを突いた様々な攻撃手法が報告されている。

### (応用)POODLE攻撃
SSL3.0で成立した攻撃。Padding Oracle On Downgraded Legacy Encryption.
具体的な手法は別ページに記載した。

### (応用)Beast攻撃
TLS1.0で成立した攻撃。Browser Exploit Against SSL/TLS.
具体的な手法は別ページに記載した。

### (応用)Bleichenbacher攻撃
いつか書く。

### (応用)ROBOT 攻撃
Return Of Bleichenbacher's Oracle Threat.
前述のBleichenbacher攻撃の亜種。
いつか書く。

### (応用)Lucky13攻撃
CBCモードの暗号化、かつMAC-then-encryptを使っている場合に有効な攻撃。
CBCモードのパディングの検証において、パディング成功時/失敗時で処理時間がわずかに異なることを利用する。
攻撃者は暗号文ブロックを改変しながら(選択暗号文攻撃)、処理時間の差を測定し、平文を1バイトずつ復元する。

統計的な情報に依存するため、10^5~10^7スケールの試行回数を要するのが特徴。
詳細な仕組みは要調査です

### (応用)Heartbleed攻撃
OpenSSLの脆弱性(CVE-2014-0160)。仕様上の問題ではなく、実装上のバグ。史上最悪の脆弱性の一つとされる。
いつか書く。

## MAC
この辺もいつか書く。
Message Authentication Code.
改ざん検知のために、メッセージに付加される短いビット列のこと。
送信者と受信者が共有する鍵を用いて計算するため、送信元の認証とメッセージの完全性を検証できる。

### CMAC
Cipher-based MAC.
ブロック暗号による暗号化で、暗号文の最後のブロックをMACとして利用する。
要調査かも

### HMAC
Hash-based MAC.RFC2104参照。
メッセージ＋鍵をハッシュ化してMACとする。
受信者は、受信したメッセージを同じ方法でハッシュ化し、MACを比較することで改ざんの有無を検証できる。
1. メッセージ+鍵 をハッシュ化
2. ハッシュ化した値 + 鍵 をハッシュ化

2回ハッシュにかけるのは、SHA-1、SHA-256などのハッシュ関数が伸長攻撃に対して脆弱なため。

### TLS 1.3 ハンドシェイクの流れ
TLS 1.3では、ハンドシェイクの流れが大幅に変更されている。どれぐらい違うかってたぶん別記事に書いた方がいいくらい違う。

::: warning
**利用可能な暗号スイート**

TLS1.3では、PFS(完全前方秘匿性)をもたない暗号スイートが廃止された。特に、RSA鍵交換や静的DHE鍵交換が廃止されている。
:::

::: info
**PFS(完全前方秘匿性)**
特定のセッションにおいて使用された鍵が漏洩したとしても、過去の通信内容が解読されない性質のこと。
RSA鍵交換ではこれが保証されない。プリマスタシークレットをサーバの公開鍵で暗号化して送信
:::