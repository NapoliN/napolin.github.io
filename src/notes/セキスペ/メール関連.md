---
title: セキスペ入門 メール
tags: 
    - セキスペ
date: 2025/10/20
---

# メール

基本的なプロトコルの内容は別途書くかもしれない。
このノートでは、送信者認証/暗号化/スパム対策など、セキュリティに関連する内容についてまとめる。

## お品書き
- 送信者認証
    - SMTP AUTH
    - SPF
    - DKIM
    - DMARC
    - (FCrDNS)
    - (POP before SMTP)
- 暗号化
    - PGP(OpenPGP)
    - S/MIME
    - SMTP over TLS
    - STARTTLS
- スパム対策
    - OP25B
    - IP25B
    - サブミッションポート


## 送信者認証
|認証技術| 役割| 補足 |
|---|---|---|
| SMTP--AUTH | 送信者と送信メールサーバ間での認証 | |
| SPF | 送信ドメインの送信元IPが、そのドメインが許可する送信サーバとして指定されているか検証 | |
| DKIM | メールがドメイン所有者(=その所有者が管理するメールサーバ)によって署名されているかを検証 | 改ざん検知もできる |
| DMARC | SPF/DKIM/Fromドメインの検証結果に基づき、送信サーバがメールをどう扱うか指示 | どちらかというと運用ポリシー的な立ち位置 |

### SMTP AUTH
[RFC4954](https://tex2e.github.io/rfc-translater/html/rfc4954.html)
SMTP-AUTHは、送信者-送信メールサーバにおいて認証を行うためのプロトコル。サーバ側はクライアントに対して認証を要求し、認証が成功した場合のみ送信が許可される。
以下は、CRAM-MD5認証方式を用いた場合のフロー例。

::: mermaid
sequenceDiagram
    participant Client as メールクライアント
    participant SendMailServer as 送信メールサーバ
    autonumber
    Client->>SendMailServer: EHLO
    Note over Client, SendMailServer: EHLOのあとに認証ステップを追加するのがSMTP-AUTH
    critical SMTP-AUTH認証フロー 
        SendMailServer-->>Client: 250-AUTH LOGIN PLAIN
        Client->>SendMailServer: AUTH CRAM-MD5
        SendMailServer-->>Client: 334 &lt;challenge&gt; <br/> (Base64エンコードされたnonceチャレンジ)
        Client->>SendMailServer: &lt;response&gt; <br/> (チャレンジに対するレスポンス)
        SendMailServer-->>Client: 235 Authentication successful
    end
    Note over Client, SendMailServer: 認証成功後、通常のSMTP通信へ
:::

1. クライアントは通常通りEHLOを送信する。
2. 送信メールサーバは、利用可能な認証方式を通知する。
3. クライアントは認証方式を指定してAUTHコマンドを送信する。
4. (以降)選択した認証方式に応じて、認証を行う。

### DKIM
DomainKeys Identified Mail.
デジタル署名を用いて送信ドメイン認証を行い、なりすましや改ざんの検知を行う技術。**メールサーバ間の認証**を行う。
正常にメールが送信された場合のフローを以下に示す。

::: mermaid
sequenceDiagram
    participant Sender as 送信者
    participant SendMailServer as 送信メールサーバ
    participant DNS as (送信元ドメインの)<br/>DNSサーバ
    participant ReceiveMailServer as 受信メールサーバ
    participant Receiver as 受信者
    autonumber
    note over SendMailServer, DNS: 鍵ペアを生成し、<br/> 秘密鍵：送信メールサーバに保存 <br/> 公開鍵：DNSサーバに登録
    Sender->>SendMailServer: メール送信
    SendMailServer->>SendMailServer: 秘密鍵で署名付与
    SendMailServer->>ReceiveMailServer: メール送信
    ReceiveMailServer->>DNS: DKIMレコード問い合わせ
    DNS-->>ReceiveMailServer: DKIMレコード取得
    ReceiveMailServer->>ReceiveMailServer: 署名検証
    Receiver->>ReceiveMailServer: メール取得
:::

1. 送信者はメールサーバに対して通常のメール送信を行う。
1. 送信元メールサーバは、ヘッダの一部＋本文をハッシュ化し、秘密鍵で署名を付与する。
1. 送信元メールサーバは、署名・セレクタ・送信ドメイン等をメールのヘッダ(DKIM-Signature)に追加し、メールを配送する。
1. 受信メールサーバは、送信ドメインのDNSサーバに対してDKIMレコードの問い合わせを行い、公開鍵を取得する。
1. 受信メールサーバは、取得した公開鍵を用いて署名を検証する。
1. 受信メールサーバは、メールを受信者に配信する。

::: info
**DNSサーバに登録するレコードのフォーマット**

DKIMレコードはTXTレコードとして以下のフォーマットで登録される。
```
<seletor>._domainkey.<domain> IN TXT v=DKIM1; k=<algorithm>; p=<pub_key_encoded_base64>
```
- **seletor**: 署名時に指定したセレクタ
- **domain**: 送信ドメイン名
- **algorithm**: 署名に用いるアルゴリズム(RSAなど)
- **pub_key_encoded_base64**: 公開鍵をBase64エンコードしたもの

:::

::: info
**署名する範囲について**

Receivedヘッダなど、配送経路で追加されることが予想されるヘッダは署名対象外にする。
署名の対象とした範囲に変更が施されると、検証に失敗し、改ざんとして扱われてしまう可能性がある。

余談として、本文の署名範囲も指定することもできる。基本は全文を対象にする(それはそう)。
:::

::: warning
DKIMで検証できるのは
- メール本文・ヘッダが改ざんされていないこと
- DKIM-signatureに指定されたドメインが送信を許可していること

であり、次のことは検証できない。
- 本当にそのドメインから送られたかどうか
:::

### SPF
[RFC7208](https://tex2e.github.io/rfc-translater/html/rfc7208.html)参照。Sender Policy Framework.

メールの送信元IPアドレスが、そのメールの送信元ドメインが指定されているものであるか確認する仕組み。
SMTPはTCPベースのプロトコルであり、送信元IPアドレスの偽装が難しい(TCPハンドシェイクによる双方向の通信となるため)ことを利用している。

::: mermaid
sequenceDiagram
    participant Sender as 送信者
    participant SendMailServer as 送信メールサーバ
    participant DNS as (送信元ドメインの)<br/>DNSサーバ
    participant ReceiveMailServer as 受信メールサーバ
    participant Receiver as 受信者
    autonumber
    Sender->>SendMailServer: メール送信
    SendMailServer->>ReceiveMailServer: メール送信
    ReceiveMailServer->>DNS: SPFレコード問い合わせ
    DNS-->>ReceiveMailServer: SPFレコード取得
    ReceiveMailServer->>ReceiveMailServer: 送信元IP検証
    Receiver->>ReceiveMailServer: メール取得
:::

1. 送信者はメールサーバに対して通常のメール送信を行う。
1. 送信元メールサーバは、受信メールサーバに対してメールを配送する。
1. 受信メールサーバは、(envelope-fromに記述される)送信ドメインのDNSサーバに対してSPFレコードの問い合わせを行い、SPFレコードを取得する。
1. 受信メールサーバは、送信元IPアドレスがSPFレコードで許可されているか検証する。
1. 受信メールサーバは、メールを受信者に配信する

::: info
**DNSサーバに登録するレコードのフォーマット**

送信側ドメインの管理者は、TXTレコードとして以下のフォーマットでSPFレコードを登録する。
(v=spf1はバージョン情報だけど、基本バージョン1しか使わない)
```
<domain> IN TXT v=spf1 <mechanism> <modifiers>
```
- **domain**: 送信ドメイン名
- **mechanism**: 許可する送信サーバを指定する仕組み。以下のような値が指定できる。
    - ip4:xxx.xxx.xxx.xxx / ip6:xxxx:xxxx:xxxx:xxxx::xxxx 指定したIPアドレス/プレフィックスからの送信を許可
    - a 指定したドメインのA/AAAAレコードに登録されているIPアドレスからの送信を許可
    - mx 指定したドメインのMXレコードに登録されているメールサーバのIPアドレスからの送信を許可
    - include:<domain> 指定したドメインのSPFレコードを参照し、許可された送信サーバを継承
    - all すべての送信元IPアドレスを対象にする(通常は最後に否定形で使用) 
:::

#### (応用)SRS
Sender Rewriting Scheme.
メール転送時にenvelope-fromアドレスを書き換える仕組み。SPF検証では、送信元IPアドレスとenvelope-fromドメインの整合性の検証を行う。
メール転送などで送信元IPアドレスが変わってしまう場合、受信メールサーバでSPF検証に失敗してしまう可能性がある。

::: mermaid
    sequenceDiagram
    
    box rgba(150, 150, 255, 0.3) example.comドメイン
        participant SendMailServer1 as 送信メールサーバ<br/>(IP: xxx.xxx.xxx.xxx) <br/> mx.example.com
        participant DNS as (送信元ドメインの)<br/>DNSサーバ <br/> ns.example.com
    end
    participant ForwardServer as 転送サーバ<br/>(IP: yyy.yyy.yyy.yyy) <br/> forward.example.net
    participant SendMailServer2 as 受信メールサーバ<br/>(IP: zzz.zzz.zzz.zzz)
    autonumber
    SendMailServer1->>+ForwardServer: メール送信<br/>envelope-from: aaa@example.com
    ForwardServer->>-SendMailServer2: メール転送<br/>envelope-from: aaa@example.com
    SendMailServer2->>+DNS: SPFレコード問い合わせ<br/>
    DNS-->>-SendMailServer2: SPFレコード取得
    note left of SendMailServer2: example.com : ip4:xxx.xxx.xxx.xxx -all
    note over SendMailServer2: 送信元IP検証失敗<br/>(yyy.yyy.yyy.yyyは許可されていない)
:::

図のように、example.comドメインから送信されたメールが、forward.example.netドメインの転送サーバを経由して受信メールサーバに届くケースを考える。
このとき、受信メールサーバはSPF検証のためにexample.comドメインのSPFレコードを問い合わせる。
example.comドメインのSPFレコードでは、許可する送信元IPアドレスとしてxxx.xxx.xxx.xxxを回答する。
しかし、受信メールサーバが受け取ったメールの送信元IPアドレスはyyy.yyy.yyy.yyyであるため、SPF検証に失敗してしまう。

この問題を解決するのがSRSである。SRSでは、転送サーバがメールを転送する際(上図でいう手順②)に、envelope-fromアドレスを自身のものに書き換える。

::: mermaid
    sequenceDiagram
    
    box rgba(150, 150, 255, 0.3) example.comドメイン
        participant SendMailServer1 as 送信メールサーバ<br/>(IP: xxx.xxx.xxx.xxx) <br/> mx.example.com
        participant DNS as (送信元ドメインの)<br/>DNSサーバ <br/> ns.example.com
    end
    box rgba(255, 150, 150, 0.3) forward.example.netドメイン
        participant ForwardServer as 転送サーバ<br/>(IP: yyy.yyy.yyy.yyy) <br/> forward.example.net
        participant ForwarderDNS as (転送サーバドメインの)<br/>DNSサーバ <br/> ns.example.net
    end
    participant SendMailServer2 as 受信メールサーバ<br/>(IP: zzz.zzz.zzz.zzz)
    autonumber
    SendMailServer1->>+ForwardServer: メール送信<br/>envelope-from: aaa@example.com
    rect rgba(219, 124, 124, 1)
    ForwardServer->>-SendMailServer2: メール転送(envelope-from書き換え)<br/>envelope-from: forwarder@example.net
    end
    SendMailServer2->>+ForwarderDNS: SPFレコード問い合わせ<br/>
    ForwarderDNS-->>-SendMailServer2: SPFレコード取得
    note left of SendMailServer2: example.net : ip4:yyy.yyy.yyy -all
    note over SendMailServer2: 送信元IP検証成功！
:::

SPF検証では、envelope-fromアドレスのドメイン(上図でいうexample.net)のSPFレコードを問い合わせる。
envelope-fromを書き換えることで、転送サーバドメインにSPFレコードを問い合わせるように指定でき、SPF検証を成功させることができる。
なお、ヘッダfromはそのままなので、受信者が読むメールには通常通り送信メールサーバのドメインが表示される。

::: warning
envelope-fromが書き換えられてしまう (ヘッダfromとenvelope-fromが一致しなくなる)ため、DMARC検証には失敗してしまうという問題がある。

cf. [Microsoft 365 の送信者書き換えスキーム (SRS)](https://learn.microsoft.com/ja-jp/exchange/reference/sender-rewriting-scheme)
:::


### DMARC
[RFC 7489](https://tex2e.github.io/rfc-translater/html/rfc7489.html)参照。Domain-based Message Authentication, Reporting, and Conformance.

受信サーバによるSPFとDKIM、およびFromドメインの整合性の検証結果から、それをどう扱って欲しいのか**送信サーバが**ポリシーを公開する仕組み。

DMARC検証はSPF/DKIM検証をベースとして、次のフローで行われる。

::: mermaid
flowchart LR
    A[メール受信] --> B[SPF検証]
    A --> C[DKIM検証]
    C --> D
    B --> D{SPF or DKIMが成功?}
    D -- 失敗 --> E(DMARC失敗)
    D -- 成功 --> F{Fromドメイン<br/>と一致？}
    F -- 一致 --> G(DMARC成功)
    F -- 不一致 --> E
:::

まず、受信メールサーバはSPF検証とDKIM検証を行う。
SPF/DKIMのいずれかが成功したとき、次にFromヘッダのドメインと、SPF/DKIMで使われたドメインが一致しているか確認する。
- SPFの場合: envelope-fromドメイン
- DKIMの場合: DKIM-Signatureヘッダのドメイン

これらがFromヘッダのドメインと一致している場合、DMARC検証は成功とみなされる。
もし、SPF/DKIMの両方が失敗するか、成功した認証方式で使われたドメインがFromドメインと一致しない場合、DMARC検証は失敗とみなされる。
DMARC検証が失敗した場合、受信サーバはドメイン管理者が指定したポリシーに従ってメールを処理する。

ドメイン管理者は、送信ドメインに
 _dmarc.<domain> のTXTレコードに、以下のようにDMARCの情報を記載する。

```
_dmarc.<domain> IN TXT v=DMARC1; p=<policy>; sp=<sub_policy>; rua=mailto:<report_address>;
```


::: info
**pタグの意味**

pタグの値によって、受信サーバがDMARC検証に失敗したメールをどう扱うか指示できる。
| タグ |  意味 |
|---|---|
| none | 検証に失敗しても特に処理しない |
| quarantine | 迷惑メールフォルダに隔離するなど、厳重に扱う |
| reject | 受信拒否する |
:::

::: info
正規のメールでも、SPF/DKIMの検証には失敗するケースは多くある。

SPF: メールを転送したとき(送信元IPアドレスが転送サーバのIPになってしまうため)
DKIM: メール本文やヘッダが途中で変更されたとき(メールサーバが自動で付与するヘッダがあるため)
:::


### FCrDNS
Foward-confirmed revers DNS.
メールを送ってきた送信サーバのIPアドレスを逆引きして、得られたホストの正引き結果がもとに戻るかを検証。

クラウド/レンタルサーバでは、1つのIPを複数ドメインが共有するケースがある。
そうしたケースでは逆引きが正しく検証できない場合がある。

### POP before SMTP
メール送信前に、POP3で認証を行う仕組み。
POP3で認証が成功したIPアドレスからのSMTP送信を一定時間許可する。

::: warning
DKIMリプレイ攻撃ってのがあるらしい。
アカウント名にフィッシング文を詰め込むことで、運営から送られるnoreplyメッセージにフィッシング文を載せることができる。
このメッセージを丸ごとスパムメールとして送信する攻撃手法。
正規ドメインのDKIM署名が付与されているため、受信側で正当なメールとして扱われてしまう。

https://innovatopia.jp/cyber-security/cyber-security-news/52148/
:::

## メールの暗号化
前述したDKIM/SPFなどの技術は、メールの送信者認証、つまり「メールを送ったのは本当にそのドメインの正当な所有者か」を検証する技術であり、メールの内容そのものを保護する技術ではない。
メールの内容を盗聴などから保護するためには、メールの暗号化が必要となる。メールの暗号化には、PGP、S/MIME、SMTP over TLS、STARTTLSなどの技術がある。

### PGP(OpenPGP)
Pretty Good Privacy。PGPは狭義にはソフトウェア名を指す。
公開鍵暗号方式を使ったメールの暗号化・デジタル署名のための規格。
署名・鍵交換・本文暗号化の3要素から構成される。
基本的には、Web of Trustで公開鍵の正当性を確保し、認証局を必要としない。
個人間のやり取りベースなので、メールアドレスごとに公開鍵/秘密鍵を用意する。
### 署名
1. 送信者がメッセージのハッシュ値に署名。
2. 受信者は送信者の公開鍵を使って、署名を検証。(改ざん検知)

#### 鍵交換
本文暗号化に用いる一時的なセッション鍵を、登録済みの相手の公開鍵を使って暗号化する。
相手は自身の秘密鍵を使ってセッション鍵を取り出し、本文を復号する。
暗号化/復号を行う必要があるので、RSAやECDHを使う。
ECDHの場合、送信者側の一時的な公開鍵も相手に送付する。

#### 本文暗号化
受信者は、鍵交換によって得た


### S/MIME
Secure/Multipurpose Internet Mail Extension
公開鍵基盤に基づく、電子メールの暗号化/署名のための規格。
メールアドレスごとに証明書を用意する。

::: mermaid
sequenceDiagram
    participant Sender as 送信者
    participant SendMailServer as 送信メールサーバ
    participant ReceiveMailServer as 受信メールサーバ
    participant Receiver as 受信者
    autonumber
    note over Sender: 受信者の電子証明書を事前に取得<br/>(相手から署名付きメールをもらう等)
    Sender->>Sender: 署名付与+証明書チェーン添付+暗号化
    critical 暗号化される範囲
        Sender->>SendMailServer: 暗号化したメールを送信
        SendMailServer->>ReceiveMailServer: メール転送
        Receiver->>ReceiveMailServer: メール取得
    end
    Receiver->>Receiver: 復号+署名検証
:::

1. 送信者はメールを署名し、送信者の証明書チェーンを添付した上で、受信者の公開鍵を用いて暗号化する。
1. 送信者は暗号化したメールを送信する。
1. 送信元メールサーバは、受信メールサーバに対してメールを配送する。
1. 受信メールサーバは、メールを受信者に配信する。
1. 受信者は、自身の秘密鍵を用いてメールを復号し、送信者の証明書チェーンを検証した上で署名を検証する。

- 送信側
 送信者の秘密鍵でメールに署名
 受信者の公開鍵で暗号化
 認証局から取得した証明書を添えて送信
- 受信側
 認証局の証明書を辿り、証明書の正当性を検証
 証明書から取り出した公開鍵を用いて署名を検証
 受信者の秘密鍵で復号
 
### SMTPS (SMTP over TLS)
[RFC8314](https://tex2e.github.io/rfc-translater/html/rfc8314.html)参照。SMTP通信をTLSセッション上で行うためのプロトコル。要するにHTTPSのSMTP版。この通信用のポートとして、465番が割り当てられている。
最初にTLSハンドシェイクを行う。サーバ間での通信を暗号化する、なのでメールサーバごとに証明書を用意する必要がある。

TLSセッション上での暗号化なので、送信者から受信メールサーバまで、サーバを挟むごとに暗号化が行われる。
なお、宛先サーバから受信者は、別のプロトコルで暗号化することができる(IMAPS, POP3S)

::: mermaid
sequenceDiagram
    participant Sender as 送信者
    participant SendMailServer as 送信メールサーバ
    participant ReceiveMailServer as 受信メールサーバ
    participant Receiver as 受信者
    autonumber
    Sender->>SendMailServer: TLS接続
    Note over Sender, SendMailServer:　セッション内でSMTP通信
    SendMailServer->>ReceiveMailServer: TLS接続
    Note over SendMailServer, ReceiveMailServer: セッション内でSMTP通信
    Receiver->>ReceiveMailServer: メール取得(POP/IMAP)
:::

::: warning
通信経路において、各サーバ上で復号されていることに注意。(end-to-end暗号化ではない)
:::


### STARTTLS
[RFC3207](https://tex2e.github.io/rfc-translater/html/rfc3207.html)参照。平文で通信が行われるプロトコルで、通信の途中から暗号化に切り替えるための拡張機能。
通信相手がTLSをサポートしていなければ、暗号化通信に切り替えることなく平文のまま通信が行われる。

::: mermaid
sequenceDiagram
    participant Sender as 送信側
    participant Receiver as 受信側

    Sender->>Receiver: EHLO
    Receiver-->>Sender: 250-STARTTLS <br/> STARTTLS対応を通知
    Sender->>Receiver: STARTTLS <br/>TLSセッションの要求
    Receiver-->>Sender: 220 Ready to start TLS
    Note over Sender, Receiver: TLSハンドシェイクを実施
    Sender->>Receiver: 暗号化セッション内でSMTP通信
:::


(SMTPを例に)
1. 平文で接続開始(EHLOを送りあう)
2. クライアント->サーバにSTARTTLSコマンドを送る
3. サーバが応答する
4. TLSハンドシェイクを行い、暗号化セッションの確立

なお、STARTTLSは通信経路の保護を保証できるものではない。
中間者が内容を傍受、改ざんできる場合、STARTTLSのための応答(これは平文で共有される)を改ざんできてしまい、暗号化通信に切り替えられないようにすることが可能。

#### 中間者が通信を改ざんして平文通信を強制する例
::: mermaid
sequenceDiagram
    participant Sender as 送信側
    participant Attacker as 攻撃者<br/>(中間者)
    participant Receiver as 受信側
    Sender->>Receiver: EHLO
    Receiver--xAttacker: 250 OK
    note over Attacker: 改ざんしてSTARTTLS対応を隠蔽
    Attacker-->>Sender: 250 OK <br/>改ざんした内容
    Sender->>Receiver: 平文でSMTP<br/> (攻撃者が傍受・改ざん可能)
:::

STARTTLSプロトコルでは、受信側がSTARTTLSに対応していることを送信側に通知する必要がある。
この通信はEHLOへの応答として平文でやり取りされるため、図のように、中間者が応答を改ざんしてSTARTTLS対応を隠蔽することが可能である。
結果として送信側は、受信側がTLS非対応であると誤認してしまい、平文でSMTP通信を行ってしまう。
このように、攻撃者が通信の改ざんを行える場合、STARTTLSそのものが無効化されてしまうため注意が必要。

## スパムメールブロック
### OP25B
Outbound Port 25 Blocking.
内部ネットワークから外部のメールサーバへのTCPポート25への通信をブロックする仕組み。
ISPが自身の管理下のIPアドレスから、外部へスパムメールを送信するのをブロックするために利用される。
出張先から自社ドメインのメール(つまり、自社のメールサーバを経由して送信)したいときは、SMTPS(Port 465)やサブミッションポート(Port 587)を使うことで、

### IP25B
ISPが動的なIPアドレスから送られてくるメールをブロックする仕組み。
ISP管理下のIPアドレス内のウィルス感染者や、独自サーバから送られるスパムメールをブロックする。

### サブミッションポート
[RFC 6409](https://tex2e.github.io/rfc-translater/html/rfc6409.html)参照。TCP Port 587番のこと。クライアントからメールサーバへの送信専用ポート。
- サーバ->サーバ間のメール配送
- クライアント->サーバ間のメール配送

を分離するための枠組み。MSAはメール送信を行うユーザに対し、メール送信前に認証を要求する。
これにより、承認されたユーザのみメール送信ができるようになり、スパムメールの踏み台にされるリスクを低減できる。

1. EHLOを送りコネクションを確立 可能ならばSTARTTLSで暗号化
2. SMTP AUTHで認証情報を送り、サーバがそれを認証する
3. 通常のSMTP同様、送信メールを送る
